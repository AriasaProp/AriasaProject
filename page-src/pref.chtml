  <main id='main'>
    <h1>Customize</h1>
    <form>
      <canvas width='180px' height='180px'><input type='hidden' name='primaryColor'></canvas>
      <canvas width='180px' height='180px'><input type='hidden' name='accentColor'></canvas>
      <canvas width='180px' height='180px'><input type='hidden' name='fontColor'></canvas>
      <br>
      <div class='kc'><h4>Font Size</h4><p>A</p><input name='fontSize' type='range' min='12' step='1' max='16'><p>A</p></div>
      <br>
      <button type='reset' disabled><i class='material-symbols-outlined'>&#xe872;</i>Reset</button>
      <button type='submit' disabled><i class='material-symbols-outlined'>&#xf5a6;</i>Apply</button>
    </form>
  </main>
  <script>
const cp = Math.PI / 180;
function clrPickC(p, radi) {
  let rad = 0;
  if (radi) p.obj.value = rad = parseInt(radi);
  else rad = parseInt(p.obj.value);
  const r = Math.min(p.canvas.clientWidth, p.canvas.clientHeight) * 0.46;
  const d = r * 0.64; // thickness of pallete
  const ctx = p.ctx;
  for (i = rad + 1; i !== rad; i = (i + 1) % 360) {
    ctx.fillStyle = `hsl(${i}, 100%, 50%)`;
    ctx.beginPath();
    let inArcX  = Math.cos(cp * (i - 0.5));
    let inArcY  = Math.sin(cp * (i - 0.5));
    ctx.moveTo(d * inArcX,d * inArcY);
    ctx.lineTo(r * inArcX,r * inArcY);
    inArcX  = Math.cos(cp * (i + 0.5));
    inArcY  = Math.sin(cp * (i + 0.5));
    ctx.lineTo(r * inArcX,r * inArcY);
    ctx.lineTo(d * inArcX,d * inArcY);
    ctx.closePath();
    ctx.fill();
  }
  ctx.fillStyle = `hsl(${rad}, 100%, 50%)`;
  ctx.beginPath();
  ctx.arc(0, 0, d, 0, Math.PI * 2);
  ctx.closePath();
  ctx.fill();
  ctx.strokeStyle = 'black';
  ctx.beginPath();
  ctx.moveTo((d - 5) * Math.cos(cp * (rad + 0.0)), (d - 5) * Math.sin(cp * (rad + 0.0)));
  ctx.lineTo((r + 5) * Math.cos(cp * (rad + 2.5)), (r + 5) * Math.sin(cp * (rad + 2.5)));
  ctx.lineTo((r + 5) * Math.cos(cp * (rad - 2.5)), (r + 5) * Math.sin(cp * (rad - 2.5)));
  ctx.closePath();
  ctx.fill();
  ctx.stroke();
  ctx.fillStyle = 'black';
  ctx.textBaseline = 'bottom';
  ctx.fillText(p.n, 0, 0);
  ctx.textBaseline = 'top';
  ctx.fillText('Color', 0, 0);
}
function redrawClrPickC(p, rad) {
  p.ctx.clearRect(-p.canvas.clientWidth * 0.5, -p.canvas.clientHeight * 0.5, p.canvas.clientWidth, p.canvas.clientHeight);
  clrPickC(p, rad);
}
let colorPickerConstant = [
  {k: 'primaryColor',n: 'Primary'},
  {k: 'accentColor',n: 'Accent'},
  {k: 'fontColor',n: 'Font'}];
colorPickerConstant.forEach(p => {
  p.obj = sett.elements[p.k];
  p.canvas = p.obj.parentNode;
  p.ctx = p.canvas.getContext('2d');
  p.ctx.textAlign = 'center';
  p.ctx.font = "normal 700 1.1em Roboto, sans-serif";
  p.ctx.translate(p.canvas.clientWidth * 0.5, p.canvas.clientHeight * 0.5);
  clrPickC(p, theme_val[p.k]);
  p.canvas.addEventListener('click', (e) => {
    const tan = Math.atan2(p.canvas.clientHeight * 0.5 - e.offsetY, p.canvas.clientWidth * 0.5 - e.offsetX);
    const rad = Math.round(180 + tan / cp);
    if (parseInt(p.obj.value) === rad) return;
    redrawClrPickC(p, rad);
    sett.dispatchEvent(new Event('change'));
  });
});
let areset = sett.querySelector('button[type="reset"]');
let asubmit = sett.querySelector('button[type="submit"]');
sett.addEventListener('change', (e) => {
  areset.disabled = false;
  asubmit.disabled = false;
});
sett.addEventListener('reset', (e) => {
  areset.disabled = true;
  asubmit.disabled = true;
  colorPickerConstant.forEach(p => redrawClrPickC(p, theme_val[p.k]));
});
sett.addEventListener('submit', (e) => {
  areset.disabled = true;
  asubmit.disabled = true;
  e.preventDefault();
  Object.keys(theme_val).forEach((k) => {
    let a = sett.elements[k];
    if (theme_val[k] !== a.value) {
      document.documentElement.style.setProperty(`--${k}`, a.value);
      theme_val[k] = a.defaultValue = a.value;
    }
  });
  localStorage.setItem('Theme', JSON.stringify(theme_val));
  colorPickerConstant.forEach(p => redrawClrPickC(p, theme_val[p.k]));
});
  </script>

